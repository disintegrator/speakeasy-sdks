/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as errors from "../models/errors";
import * as operations from "../models/operations";

export class Offerings extends ClientSDK {
    private readonly options$: SDKOptions;

    constructor(options: SDKOptions = {}) {
        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
        });

        this.options$ = options;
        void this.options$;
    }

    /**
     * Create an offering
     */
    async createOffering(
        filter?: string | undefined,
        requestBody?: operations.CreateOfferingRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateOfferingResponse> {
        const input$: operations.CreateOfferingRequest = {
            filter: filter,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.CreateOfferingRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/subscriptions/offerings")();

        const query$ = [
            enc$.encodeForm("filter", payload$.filter, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 201, "application/json")) {
            const responseBody = await response.json();
            const result = operations.CreateOfferingResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * List offerings
     */
    async listOfferings(
        filter?: string | undefined,
        pageOffset?: number | undefined,
        pageLimit?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.ListOfferingsResponse> {
        const input$: operations.ListOfferingsRequest = {
            filter: filter,
            pageOffset: pageOffset,
            pageLimit: pageLimit,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.ListOfferingsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/subscriptions/offerings")();

        const query$ = [
            enc$.encodeForm("filter", payload$.filter, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page[limit]", payload$["page[limit]"], {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("page[offset]", payload$["page[offset]"], {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ListOfferingsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Build an offering
     */
    async buildOffering(
        input: operations.BuildOfferingRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.BuildOfferingResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.BuildOfferingRequestBody$.outboundSchema
            .optional()
            .parse(input);
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/subscriptions/offerings/build")();

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 201, "application/json")) {
            const responseBody = await response.json();
            const result = operations.BuildOfferingResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get offering
     */
    async getOffering(
        offeringUuid: string,
        options?: RequestOptions
    ): Promise<operations.GetOfferingResponse> {
        const input$: operations.GetOfferingRequest = {
            offeringUuid: offeringUuid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetOfferingRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/offerings/{offering_uuid}")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetOfferingResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 404, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Delete offering
     *
     * @remarks
     * When a subscription is created, it creates a snapshot of the offering. This means you can delete an offering without affecting any active subscriptions.
     */
    async deleteOffering(
        offeringUuid: string,
        options?: RequestOptions
    ): Promise<operations.DeleteOfferingResponse> {
        const input$: operations.DeleteOfferingRequest = {
            offeringUuid: offeringUuid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.DeleteOfferingRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/offerings/{offering_uuid}")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, 500, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeleteOfferingResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Update an offering
     *
     * @remarks
     * After saving an offering, you can update an offering at any time. Updating an offering does not affect any active subscriptions. The changes take effect on all new subscriptions that are created.
     *
     */
    async updateOffering(
        offeringUuid: string,
        requestBody?: operations.UpdateOfferingRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.UpdateOfferingResponse> {
        const input$: operations.UpdateOfferingRequest = {
            offeringUuid: offeringUuid,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.UpdateOfferingRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/offerings/{offering_uuid}")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UpdateOfferingResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 403, 404, 409, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * List an offering's plans
     */
    async listOfferingPlans(
        offeringUuid: string,
        pageOffset?: number | undefined,
        pageLimit?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.ListOfferingPlansResponse> {
        const input$: operations.ListOfferingPlansRequest = {
            offeringUuid: offeringUuid,
            pageOffset: pageOffset,
            pageLimit: pageLimit,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.ListOfferingPlansRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/subscriptions/offerings/{offering_uuid}/plans")(
            pathParams$
        );

        const query$ = [
            enc$.encodeForm("page[limit]", payload$["page[limit]"], {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("page[offset]", payload$["page[offset]"], {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ListOfferingPlansResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [404, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Attach a plan
     *
     * @remarks
     * After saving an offering, you can attach new plans to it at any time.
     *
     * Attaching new plans to an offering does not affect any existing active subscriptions. The changes take effect on all new subscriptions that are created.
     *
     */
    async attachOfferingPlan(
        offeringUuid: string,
        requestBody?: operations.AttachOfferingPlanRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.AttachOfferingPlanResponse> {
        const input$: operations.AttachOfferingPlanRequest = {
            offeringUuid: offeringUuid,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.AttachOfferingPlanRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/offerings/{offering_uuid}/plans/attach"
        )(pathParams$);

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.AttachOfferingPlanResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 403, 404, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Updates a plan in an offering
     */
    async updateOfferingPlan(
        offeringUuid: string,
        planUuid: string,
        requestBody?: operations.UpdateOfferingPlanRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.UpdateOfferingPlanResponse> {
        const input$: operations.UpdateOfferingPlanRequest = {
            offeringUuid: offeringUuid,
            planUuid: planUuid,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.UpdateOfferingPlanRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
            plan_uuid: enc$.encodeSimple("plan_uuid", payload$.plan_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}"
        )(pathParams$);

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UpdateOfferingPlanResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 403, 404, 409, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Remove a plan from an offering
     *
     * @remarks
     * After saving an offering, you can remove plans from it at any time.
     *
     * Removing a plan from an offering does not affect any existing active subscriptions. The changes take effect on all new subscriptions that are created.
     *
     */
    async deleteOfferingPlan(
        offeringUuid: string,
        planUuid: string,
        options?: RequestOptions
    ): Promise<operations.DeleteOfferingPlanResponse> {
        const input$: operations.DeleteOfferingPlanRequest = {
            offeringUuid: offeringUuid,
            planUuid: planUuid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.DeleteOfferingPlanRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
            plan_uuid: enc$.encodeSimple("plan_uuid", payload$.plan_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/offerings/{offering_uuid}/plans/{plan_uuid}"
        )(pathParams$);

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, [400, 403], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeleteOfferingPlanResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * List an offering's products
     */
    async listOfferingProducts(
        offeringUuid: string,
        pageOffset?: number | undefined,
        pageLimit?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.ListOfferingProductsResponse> {
        const input$: operations.ListOfferingProductsRequest = {
            offeringUuid: offeringUuid,
            pageOffset: pageOffset,
            pageLimit: pageLimit,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.ListOfferingProductsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/offerings/{offering_uuid}/products"
        )(pathParams$);

        const query$ = [
            enc$.encodeForm("page[limit]", payload$["page[limit]"], {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("page[offset]", payload$["page[offset]"], {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ListOfferingProductsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [404, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Attach a product
     *
     * @remarks
     * After saving an offering, you can attach new products to it at any time.
     *
     * Adding new products does not affect any existing active subscriptions. The changes take effect on all new subscriptions that are created.
     *
     */
    async attachOfferingProduct(
        offeringUuid: string,
        requestBody?: operations.AttachOfferingProductRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.AttachOfferingProductResponse> {
        const input$: operations.AttachOfferingProductRequest = {
            offeringUuid: offeringUuid,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.AttachOfferingProductRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/offerings/{offering_uuid}/products/attach"
        )(pathParams$);

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.AttachOfferingProductResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 403, 404, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Updates a product in an offering
     *
     * @remarks
     * Use the unique identifier of the product in the offering that you want to update. Any modifications that you make to the products in an offering, does not affect any active subscriptions. The changes take effect on all new subscriptions that are created.
     */
    async updateOfferingProduct(
        offeringUuid: string,
        productUuid: string,
        requestBody?: operations.UpdateOfferingProductRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.UpdateOfferingProductResponse> {
        const input$: operations.UpdateOfferingProductRequest = {
            offeringUuid: offeringUuid,
            productUuid: productUuid,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.UpdateOfferingProductRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
            product_uuid: enc$.encodeSimple("product_uuid", payload$.product_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/offerings/{offering_uuid}/products/{product_uuid}"
        )(pathParams$);

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UpdateOfferingProductResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, [400, 403, 404, 409, 500], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Remove a product from an offering
     *
     * @remarks
     * After saving an offering, you can remove products from it at any time.
     *
     *  Removing a product from an offering does not affect any existing active subscriptions. The changes take effect on all new subscriptions that are created.
     *
     */
    async deleteOfferingProduct(
        offeringUuid: string,
        productUuid: string,
        options?: RequestOptions
    ): Promise<operations.DeleteOfferingProductResponse> {
        const input$: operations.DeleteOfferingProductRequest = {
            offeringUuid: offeringUuid,
            productUuid: productUuid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.DeleteOfferingProductRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            offering_uuid: enc$.encodeSimple("offering_uuid", payload$.offering_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
            product_uuid: enc$.encodeSimple("product_uuid", payload$.product_uuid, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent(
            "/subscriptions/offerings/{offering_uuid}/products/{product_uuid}"
        )(pathParams$);

        let security$;
        if (typeof this.options$.bearerToken === "function") {
            security$ = { bearerToken: await this.options$.bearerToken() };
        } else if (this.options$.bearerToken) {
            security$ = { bearerToken: this.options$.bearerToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else if (this.matchResponse(response, [400, 403], "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeleteOfferingProductResponse$.inboundSchema.parse(responseFields$);
    }
}
